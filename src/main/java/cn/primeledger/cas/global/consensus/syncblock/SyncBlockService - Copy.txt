package cn.primeledger.cas.global.consensus.syncblock;

import cn.primeledger.cas.global.Application;
import cn.primeledger.cas.global.blockchain.Block;
import cn.primeledger.cas.global.blockchain.BlockService;
import cn.primeledger.cas.global.common.entity.BroadcastMessageEntity;
import cn.primeledger.cas.global.common.entity.UnicastMessageEntity;
import cn.primeledger.cas.global.common.event.BroadcastEvent;
import cn.primeledger.cas.global.common.event.UnicastEvent;
import cn.primeledger.cas.global.p2p.channel.ChannelMgr;
import com.alibaba.fastjson.JSON;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import javafx.util.Pair;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static cn.primeledger.cas.global.constants.EntityType.*;

/**
 * @author yuanjiantao
 * @date Created on 3/8/2018
 */
@Component
@Slf4j
public class SyncBlockService implements InitializingBean {

    @Autowired
    private BlockService blockService;

    private ThreadPoolExecutor executor;

    private List<Pair<String, Long>> list;

    CountDownLatch countDownLatch;

    @Autowired
    private ChannelMgr channelMgr;

    @Override
    public void afterPropertiesSet() {

        list=new ArrayList<>();

        countDownLatch = new CountDownLatch(1);

        executor = new ThreadPoolExecutor(2, 5, 100, TimeUnit.MILLISECONDS, new LinkedBlockingDeque<>(),
                new ThreadFactoryBuilder().setNameFormat("sycBlock-pool-%d").build());
        executor.allowCoreThreadTimeOut(true);


        executor.execute(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                LOGGER.error(e.getMessage(), e);
            }
            while (true) {
                if (channelMgr.getActiveChannelCount() > 0) {
                    askMaxHeight();
                    break;
                }
            }
        });

        executor.execute(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                LOGGER.error(e.getMessage(), e);
            }
            while (true) {
                if (list.size() > 0) {
                    long myMaxheight = blockService.getMaxHeight();
                    List<Pair<String, Long>> list1 = Lists.newArrayList(list);
                    list1.sort((a, b) -> (int) (a.getValue() - b.getValue()));
                    long maxHeight = list1.get(list1.size() - 1).getValue();
                    int startIndex = 0;
                    int size = list1.size();
                    for (long i = 0l; i < maxHeight - myMaxheight; i++) {
                        if (i + myMaxheight > list1.get(startIndex).getValue()) {
                            startIndex = startIndex + 1;
                        }
                        int offect = (int) (i % (size - startIndex));
                        Inventory inventory = new Inventory();
                        inventory.setHeight(i + myMaxheight);
                        unicastInventory(inventory, list1.get(startIndex + offect).getKey());
                    }
                    break;
                }
            }
        });

        executor.execute(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                LOGGER.error(e.getMessage(), e);
            }

            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                LOGGER.error(e.getMessage(), e);
            }
            if (map.size() == 0) {
                LOGGER.info("no maxHeight replied by peers!");
            } else {

            }
            while (true) {
                if (null != pair) {
                    long maxHeight = pair.getValue();
                    for (long i = 2L; i < maxHeight; i++) {
                        Inventory inventory = new Inventory();
                        inventory.setHeight(i);
                        unicastInventory(inventory, pair.getKey());
                    }
                    break;
                }
            }
        });

    }

    public void sendBlock(Block block, String sourceId) {
        UnicastMessageEntity entity = new UnicastMessageEntity();
        entity.setType(BLOCK_BROADCAST.getCode());
        entity.setVersion(block.getVersion());
        entity.setData(JSON.toJSONString(block));
        entity.setSourceId(sourceId);
        Application.EVENT_BUS.post(new UnicastEvent(entity));
        LOGGER.info("send inventory response");
    }

    public void addMaxHeight(Long height, String sourceId) {
        list.add(new Pair<>(sourceId, height));
    }

    public void askMaxHeight() {
        MaxHeight maxHeight = new MaxHeight();
        BroadcastMessageEntity entity = new BroadcastMessageEntity();
        entity.setType(MAXHEIGHT.getCode());
        entity.setVersion(maxHeight.getVersion());
        entity.setData(JSON.toJSONString(maxHeight));
        Application.EVENT_BUS.post(new BroadcastEvent(entity));
        LOGGER.info("broadcast maxHeight success: " + JSON.toJSONString(maxHeight));
    }

    public void unicastMaxHeight(MaxHeight maxHeight, String sourceId) {
        if (null == maxHeight) {
            return;
        }
        UnicastMessageEntity entity = new UnicastMessageEntity();
        entity.setType(MAXHEIGHT.getCode());
        entity.setVersion(maxHeight.getVersion());
        entity.setData(JSON.toJSONString(maxHeight));
        entity.setSourceId(sourceId);
        Application.EVENT_BUS.post(new UnicastEvent(entity));

        LOGGER.info("unicast inventory success: " + JSON.toJSONString(maxHeight));
    }

    public void unicastInventory(Inventory inventory, String sourceId) {
        if (null == inventory) {
            return;
        }
        UnicastMessageEntity entity = new UnicastMessageEntity();
        entity.setType(INVENTORY.getCode());
        entity.setVersion(inventory.getVersion());
        entity.setData(JSON.toJSONString(inventory));
        entity.setSourceId(sourceId);
        Application.EVENT_BUS.post(new UnicastEvent(entity));

        LOGGER.info("unicast inventory success: " + JSON.toJSONString(inventory));
    }
}
