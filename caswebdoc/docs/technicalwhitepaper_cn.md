<p><h1 class="main-title">
    <img src="/img/cas.png"/>
    <span>CAS 技术白皮书</span></h1></p>
<h5 align="center">版本 1.0 </h5>

## 第一章 摘要

本文主要介绍基于区块链技术构建的CAS的产品架构和技术特色。 

区块链作为比特币的底层技术，是去中心化无信任环境中的一种共识机制。区块链目前主要分为三种，公链、联盟链和私有链，联盟链和企业私有链只限于联盟成员间和企业内部。

目前，区块链的价值网络属性在公链中得到了较好的体现。根据 coinmarketcap.com的统计，截止本文成稿时间，比特币的市值已经超过750亿美元，以太坊的市值也已超过340亿美元。

区块链的核心价值在于构建可信任的去中心的体系，未来有潜力成为构建价值互联网的基础设施。CAS的定位是基于区块链技术提供金融行业的基础设施平台，平台具备分布式、高可靠、去中心化、高性能等特点，同时具备快速构建上层应用业务的能力，满足大规模的应用场景。

## 第二章 我们的目标 

CAS的目标是构建一个可以满足金融行业的融资、交易和支付场景的区块链信任和价值网络，并为各类第三方金融业务提供快速构建应用的生态环境。

## 第三章产品设计和架构设计 

### CAS功能详述 

CAS是一个去中心化的区块链网络，它将数据以分布式的方式存储在不同的节点上以达到冗余的目标，CAS网络的主要功能包含以下三个方面：

+ 实现一个经过优化设计的区块链系统。

+ 提供面向金融系统定制的、简单可靠的智能合约能力。

+ 构建民主共治式的、去中心化的经济系统。

### CAS系统的分层和平坦模型

BTC和Ethereum都采用了平坦（flat）设计模型，通过平坦模型易于实现基于P2P的系统架构，P2P架构也是CAS实现价值网络系统的必备条件。

分层架构的优点是可以实现功能的高内聚和低耦合，更加符合开放-封闭原则。另外，分层架构模型更易于满足性能需求，全量数据的网络广播本身就是一种低效但精确的方法，只要有足够的时间，信息就能够得到精准的同步，但在效率方面略有不足。

CAS系统既需要支持价值网络的基本需求，也需要支持上层金融业务系统的复杂业务需求，因此，架构的设计采用一种混合模型：在分层架构中实现平坦模型。

#### 分层架构设计概要 

<img src="/img/cas1.jpg" >

如上图示意，通用功能平台之上分为两个部分：

+ CAS平台基础服务提供层向真实的业务系统提供统一的接口集合。

+ P2P Flat-system子系统内部将实现P2P网络模型，通过VN的通用功能平台接口集调用核心的区块链服务。

在分层架构中实现平坦模型，不但保证了帐务数据的精确同步，还最大程度上保证了打包生成区块的效率，并且针对不同业务系统的需求，设计了基础服务提供层。

#### CAS软件架构详细描述 

#### 整体架构 

CAS系统整体架构的混合模型结构：

CAS系统的主要子系统包含Runtime Sandbox、Application Instance、Synchronizer、Distributed Storage等。下图是CAS系统的概要说明图，该模型中既包含运行货币账务系统的Flat模型，同时也包含多个构建在CAS平台之上的金融业务。从图中可以看到，所有的下发到底层系统的请求路径是基本一致的，其中CT0针对货币账务系统，CT1针对是实际业务场景。（在随后的术语表中会对这些关键术语做详细的说明）

通过在VN上提供接口集合可以对不同的业务形态提供支持。RS基于开放设计原则（开源，按照业务要求的定制化设计），有很强的可扩展性。 
 
<img src="/img/cas3.png" >

#### CAS 主流程介绍 

#### 术语表 

|    CAS 系统术语    | 附注解释 |
| ---------- | --- |
| CAS | Crypto Currency Asset Security |
| RS | Runtime Sandbox |
| VN | Virtual Net |
| AI | Application Instance |
| Slave Node | CAS Slave |
| Synchronizer | Ordering Queue |
| CT | CAS Trade |
| P2P Flat-subsystem | Flat model for P2P network |
| Message Broadcast | Broadcast message to all wallet |


#### 软件主要子系统详细描述 

#### CT

CAS将有各种不同的业务逐步地接入到系统中，各业务有自己特殊的业务需求，这些业务的逻辑（也包含对平台提供的通用功能接口集合的调用）均在CAS Trade中实现。

#### RS 

RS将会容纳一个处于某个业务中的功能节点，平台会提供通用功能的RS，为了对不同的业务系统提供强大的兼容性，业务的个性化支持放在定制RS中处理，隶属于CT。

#### VN

VN是实现CT功能的一个组件，通过运行Policy中的智能合约完成选举、业务隔离等功能。

#### Synchronizer

Synchronizer主要实现交易指令的打包、同类型指令排查等功能。

#### CAS Slave

区块链核心子系统，实现UTXO账户双花校验、打包区块等逻辑，Slave也负责所有区块链数据的持久化存储。

#### AI

这个模块为业务API接口集，该接口集是由不同业务根据自身需求而实现，能够方便的对新系统或已有系统进行接入。

#### P2P Flat-subsystem

该组件是由CAS平台提供（为方便二次开发，也提供SDK开发工具），专为代币系统设计，该模型中包含平台自主实现的P2P网络用于支撑公链必须的消息广播系统，同时，在CAS系统中也内置了多种消息协议。

#### 消息广播

消息广播系统，该系统运行在各个钱包上，主要目的是进行消息广播，确保新消息发送到Flat-subsystem中的其他节点上。

### CAS的整体流程图 

#### 分层架构的主要数据流程  

<img src="/img/cas4.png" >

#### 分层架构数据流程简要介绍 
+ 交易请求通过AI调用RS接口从而将交易请求发向RS。
+ RS通过状态推进，将请求下发至VN。
+ VN解析Policy，运行Policy所携带的智能合约，完成业务投票
+ VN生成标准化指令（instruction），继续向synchronizer传递请求。
+ Synchronizer安全鉴权。 
+ 生成package（package是多个instruction集合）。
+ Synchronizer将package发送至Slave。
+ micro-slave节点进行双花判断（多节点并发投票）。
+ micro-slave节点进行block打包。
+ block完成本地存储。
+ 广播block。
+ Synchronizer将block回送至特定VN。
+ VN根据Policy隐匿数据后回送至RS。
+ RS对数据进行解析，更新本地账本并将结果返回至AI，AI调用上层业务系统提供的接口实现结果回传。

#### 平坦模型 

CAS的平坦模型专为货币账务系统（包含CAS货币和业务代币）设计，P2P Flat-subsystem是货币的发行和流转的底层软件支撑模块，实现了如下主要功能：

+ 实现一个P2P网络，该网络用于支撑其上接入的所有钱包中的货币（包含CAS币和业务代币）发行、流转等需求。

+ 为运行智能合约提供底层环境支撑。

+ 实现一套定制化的、安全的应用级消息协议用于支持消息的传播。


#### P2P Flat-subsystem 数据流程  

<img src="/img/cas5.png" >

#### P2P Flat-subsystem 数据流程概要介绍 

+ 某个钱包创建一个transaction（可能包含智能合约），通过P2P网络广播。

+ P2P节点接收消息，校验成功后接力广播。

+ 合约账户接受消息，运行合约，调用RS接口访问区块链系统。

+  RS传递tx进入VN。

+ VN根据Policy运行智能合约。

+ 下发到核心区块链系统（这里与前面的分层架构中的流程是一致的）完成双花验证、打包区块并返回。

+ 完成一次交易以后，广播消息。

+ 各钱包账户（如果是SPV账户则无需同步信息）信息同步。

### CAS关键技术设计 

#### CAS Coins 

区块链系统具有去中心化特性的同时也意味着没有中心化的网络维护者，网络运行依靠参与节点共同维护。为了使参与节点有足够的动力维护网络的稳定运行，有必要对维护平台运行的节点进行奖励，CAS Coins是CAS生态环境中的主要奖励机制。

CAS Coins必须具有价值才能让参与节点持续投入资源维护平台的健康发展，随着CAS生态系统的不断发展壮大，CAS Coins的持有者应当能够’享受到价值收益，从而鼓励更多的参与者参与CAS平台的生态建设。

在CAS Coins具有价值的前提下，同时还必须拥有货币的支付属性。

#### CAS Coins的价值属性 

CAS Coins作为平台运行的重要奖励机制，其价值主要体现在如下几个方面：

+ CAS平台上的业务对于CAS Coins的需求 
CAS平台可以运行各类第三方的金融行业应用，并为这些业务提供记账、交易和支付服务。提供这些服务的CAS网络节点将收取一定数量的CAS Coins。

+ CAS平台用户对于CAS价值的认可 
基于CAS平台的金融应用和金融服务不断增加，将进一步提高市场和用户将对CAS生态系统的信心和预期，代表平台基础设施的CAS Coins也会在市场上得到更好的定价。

+ CAS Coins的持有者将能够从CAS生态系统的发展中获得成长收益。 

CAS系统通过机制设计，将整个生态系统的发展红利分享给CAS Coins的持有者，持有者会更加倾向于维护平台的良性发展从而保障自己的利益。

#### CAS Coins的支付职能 

CAS Coins是CAS生态系统中的基本记账单位和支付单位。CAS平台会提供标准的钱包接口和钱包客户端让用户方便的使用CAS Coins的支付职能，支付职能既体现为用户之间进行点对点的支付，也体现为通过CAS网络的智能合约，进行支付订单之间的去中心化自动撮合。

CAS在如下业务使用中会以CAS Coins作为手续费：

+ CAS 平台的支付业务会向发起人收取一定数量的CAS Coins作为手续费，手续费由CAS记账节点所分享。

+ CAS平台的去中心化交易业务会向交易双方收取一定比例的交易撮合手续费。

+  CAS平台的智能合约运行不收取额外的手续费。

#### 业务代币 
业务代币是由业务方在CAS平台中发行的，用于流通的代币。它区别于CAS币，无法用于打包费用的支付，面向的用户群更小，只与该业务方相关。但从另一个方面来说，它可以准确地体现业务的价值，作为一种在特定业务中使用的支付手段，支持业务的闭环运行。

下面会通过业务代币的价值属性和支付属性来介绍它的运作方式和用途。

#### 业务代币的价值属性 

第三方业务可以发行代币作为其商业模式运行的支付和记账单位，这种发行代币的方式将被CAS系统内置的智能合约所支持，用户通过智能合约购买的代币，会以数字资产的形式记录在CAS区块链上。良好发展的第三方业务，其本身的商业价值逐渐会反映到业务代币的价值上，持有业务代币的用户，将享受其商业价值增长带来的红利。

CAS平台上的业务代币的流转过程如下图所示：

<img src="/img/cas6.png" >

具体过程描述如下：

+ 业务方在CAS平台上请求发行代币。

+ CAS网络将初始业务代币发放至业务方的钱包。

+ 用户A向CAS网络发起购买代币的请求。

+ CAS网络将用户A的CAS币转账到发行者的钱包。

+ CAS网络把业务代币从业务方的钱包转到用户A的钱包中。

+ 用户A向CAS网络发起业务代币转账请求。

+ CAS网络将用户A的业务代币转移到用户B的钱包中。

#### 业务代币在交易平台流通 

业务代币的价值属性还体现在更大范围的机构和个人购买持有，这需要业务代币对交易平台提供标准的支持。

为了保证这种流通性，业务代币的设计中必须要能够支持ERC20协议，通过对该协议的支持，则业务代币可以在各个具有规模的交易所（目前较大规模的交易所基本都支持ERC20协议）进行交易。

#### 业务代币的支付属性 

CAS上的业务代币除了价值属性，还可以用来支付业务流转过程中的费用，这称为它的支付属性。CAS系统提供了Policy机制，允许第三方业务定制灵活的计价规则来区分不同的业务类型的收费。

#### 支付业务费用 

业务方无法免费地支撑一个业务的持续运营。运营业务的过程中，需要投入人力、物力和财力，比如运营费用、硬件设施、支付给CAS打包节点的费用等等。为了平衡开支，业务方可能会选择要求业务使用者通过支付业务代币作为业务运行的费用，CAS平台通过Policy机制和智能合约机制可以支持高度定制化的支付需求和费用计算。

#### 通过Policy制定业务代币的使用方式 

业务方可以通过编写Policy将收费的规则具化。比如制定一个简单的规则，一笔业务收取一个业务代币；在交易发生时，RS执行Policy的过程中会将用户持有的业务代币作为费用支付给业务方。

如果业务方有定制需求，比如转账和提现两种业务类型需要收取不同的费用，业务方可以在Policy的智能合约中制定规则，即转账业务和提现业务分别收取对应费用。

#### 账户和余额设计 

使用最为广泛的账户余额记录类型。

#### 通用的账务余额 

在传统的集中式账务设计中，主要采用的记账方式是流水账和会计账，前者主要是用于记录流水、余额等，而后者主要是用于输出标准的会计报表。在信息化系统中，这两种记账方式最终都依赖于数据库来持久化最终结果。

#### UTXO

UTXO: Unspent Transaction Output，这是目前公链上采用的最多的用于账务记录的模型，在代币领域多数采用这个模型，UTXO也可以说是BTC的最核心的设计之一，UTXO记录的是属于账户未被花掉的余额，其记录方式是以transaction为粒度的，也就是说一个账户（或地址）收到的一个转入账户（或地址）的transaction是唯一的，而如果从这个地址再向外转出则会使用另一个新生成的transaction来表达，UTXO模型的优点是对双花的判断比较简单，因此每个transaction都会有一个是否已花费的状态来记录该transaction是否可用，简言之，就是一个transaction只能被花费一次。

#### 两种账户余额的优缺点比较 

传统的余额记录方式（无论是流水账还是会计账）最终都是通过DB来持久化记录，每个用户的账务记录对应一条DB的记录。采用传统记账方式来处理代币在信息的隐匿上可能会存在问题，该问题在判断双花上会显现出来：如A给B转20块，此时传统的账务系统必须要对A的账户进行检查，确保它至少有20块可用余额并且冻结这20块（也就是使得该账户可用余额减少20块），这样就要求账务系统必须记录A的所有信息。在这种模型下，在系统的任何部分处理双花校验都需要记录所有的交易参与方的信息。

UTXO在双花判断上将具有巨大的优势，因为UTXO模型只需要暴露某个transaction ID，而校验模型只需要校验这个transaction的状态就可以判断其对应的余额是否可用，由于transaction只能使用一次，采用UTXO模型避免了双花的风险，同时UTXO并不要求要得到A账户的所有信息，这样就完成了信息的隐匿。

UTXO解决了双花校验和信息隐匿性的问题，但一个账户中存在大量的transaction，会增加账务处理的复杂性。

#### CAS的选择  

CAS系统既要能够承载传统的金融业务，同时也要能够承载现有公链中最典型的业务（这里主要包含代币的发行、流转等）。采用余额账务系统来记录余额、流水等数据，相关信息都是透明的；而对于公链上的代币交易来说，必须要保证信息的隐匿性。

余额账务模型虽然在传统业务中有较大优势，也经过了时间和行业的验证，然而代币业务使用这种模型进行双花判断则一定要在底层存储所有账户的具体信息从而破坏信息隐匿性，对于公链，这种做法是不能被接受的。因此，CAS将会主要使用UTXO模型支持代币类业务，同时RS还会使用余额账务模型支持传统业务，所以CAS需要支持UTXO模型向余额账户模型的转换，如下图所示：

<img src="/img/cas8.png" >

另外，UTXO过多会使其变得更复杂，CAS考虑会使用以下方式来减少账户的可用UTXO：

+ 前置合并：交易时合并出款方的多个可用UTXO（总金额大于交易所需额度），这样，交易后此账户的可用UTXO会减少。

+ 后置合并：交易后将账户相关的所有的可用UTXO合并成一个，即在任一时刻，所有账户都只有一个可用的UTXO。这种情况下，UTXO会近似于余额账户模型。

#### CAS的共识挖矿模型 

#### 现有模型缺陷 

目前无论是BTC还是Ethereum都是通过全网挖矿实现共识，然而使用全网共识效率低，这也是比特币10分钟出一个块的原因。以太坊基于对于比特币传播的分析发现在12s之内区块可以传播到全网的95%，将一个区块的生成时间设置为12s，即使以太坊根据实践数据将区块生成速度大幅提升，对于实际业务系统来说，12s的时延可能依然很难接受。

为了解决效率问题，必须从全网共识转向小部分共识。Dash币提出Masternodes共识的解决方案、Bitshare提出DPOS的解决方案，通过持有代币作为权益证明，将全网共识改为代币持有人之间的共识。根据 POS 的经济学理论，如果网络中的一个人持有大量的代币，他本身是没有动机去破坏这个网络而导致这种代币的价值损失的。因此只要赋予这些打包节点具备持有这些代币的理由，理论上说他们就没有足够的动机去尝试刻意的“分叉”操作。然而这种方式也形成了准入门槛，主要体现在两方面：

+ 早期进入的用户可以凭借较低的价格持有大量代币，后来者如果需要获得相同的权益则需要耗费巨大的成本。以Dash币价格为例，在发行初期，2014年2月14日每个Dash币价格为0.214美元，在 2017年8月27日，Dash币的价格为378.1美元，获取相同的权益两者花费相差1766倍；以2017年1月1号价格11.22为例，与2017年8月27日相比两者相差33倍。
+ 不持有代币，只提供资源无法参与打包激励分配。无论是Dash币或者Bitshare，如果未持有平台代币，无论拥有多少资源也无法参与平台打包激励分成，这也导致了比特币或者以太坊的资源无法直接转化为基于POS共识平台的资源。
CAS利用DPOS+POW共识挖矿模型，在解决效率问题的同时可以降低新节点的准入门槛。

#### 改进的DPOS共识算法 

CAS为了达到秒级性能要求，共识算法使用DPOS，任何持有多于N（待定）个代币的账户可以申请为POS节点，POS节点内部通过共治选举的方式（投票、或者通过类似于POOL的方式，两种方式的本质还是选举）来实现对DPOS节点的选择，选择DPOS的原因是对POS节点中提供的优质资源进行奖励，通常对于DPOS节点的选择标准是提供较好的IDC条件、专线接入并且持有较大量的CAS代币，优质资源可以达到更好的共识效率和共识正确性，同时由于共识节点持有较多CAS Coins也会有积极的意愿来维护CAS系统的准确性。

传统DPOS在一次共识的过程中只有一个节点参与，如果选择的DPOS节点为恶意节点那么会出现短暂分叉，在系统运行过程中依赖最长链来解决分叉问题，这样也导致了在一轮共识中数据的不可靠，可能在几轮之后，异常链上的数据被抛弃。在比特币和以太坊平台上，解决方法是等待一定数量的后续区块确认，只有后续一定数量区块的确认之后才认可交易确认或者请求被正确处理。这种处理方式对于业务接入会更加麻烦，对于业务看到的情况可能是请求被区块链处理返回之后，一段时间后区块链上的数据消失了。如果采用与比特币或者以太坊一样的策略，那么在DPOS确认之后，业务需要等待后续一定数量的区块确认才真正处理区块链返回的结果（根据后续区块确认情况来判断返回的结果是否在主链上），那么实际上区块的处理时延需要加上后续区块生成时延。同时由于需要等待一定数量区块的确认，这种逻辑的复杂性需要业务来处理，从而导致业务开发会变得非常复杂，增加已有应用迁移改造成本。

由于传统DPOS中一轮共识数据不可靠的问题导致业务的复杂性增加和时延变长，CAS系统对传统的DPOS进行了改进，在一轮共识中进行一致性的投票，共识不再是由一个节点打包进行广播而是所有DPOS节点通过一致性算法进行投票，DPOS多数派达成共识之后返回区块并且在所有DPOS节点中进行广播，当业务系统收到区块链的返回之后就可认为数据已经是可靠的，而无需等待后续一定数量区块的确认，通过多数派DPOS节点的共识过程，区块链可靠性提升、时延降低的同时业务接入的难度降低。?

#### 区块广播模型 

对于区块的广播采用分层广播模型，在DPOS节点达成共识之后，区块的分发模式为两层广播模型：

+ 一层区块广播分发：DPOS节点将区块传播给相邻的POS节点。

+ 二层区块广播分发：POS节点将区块传播给非POS节点。

通过这种分层广播模型，可以最快的将新生成的区块传播给网络中持有代币的节点。

<img src="/img/cas10.png" >

#### 共识奖励 

DPOS共识打包区块之后会有共识奖励，投票达成共识的节点分享共识奖励的70%（待定），未达成共识的DPOS节点无奖励，其余POS节点分享共识奖励的30%（待定），通过这种奖励机制，会有更多节点想要成为DPOS节点，也会对恶意DPOS的节点进行监督，通过对于POS节点的奖励鼓励POS节点持有更多的代币，提供更好的资源，也避免代币的集中，在出现恶意节点的时候可以成为新的DPOS节点，同时POS节点也可以是挖矿节点，参与POW挖矿。

DPOS节点可以对恶意节点和资源较差的节点进行惩罚，比如节点连续N次（待定）投票与多数派不同，DPOS节点可以发起惩罚投票，对恶意节点进行剔除操作，选举新的DPOS节点来接替恶意节点，新的DPOS节点从POS节点中进行选择；对于资源较差的节点（多次投票超时或者响应慢的节点）进行黑名单机制，在黑名单时间内无收益，多次黑名单进行剔除操作。通过惩罚机制来保证DPOS节点数据的正确性和效率，为全网提供优质的共识服务。

#### 挖矿奖励 

CAS同时提供POW挖矿机制，新加入的节点对DPOS生成的区块进行寻找逆HASH的工作量证明，POW将通过工作量证明机制来确保DPOS生成的记账结果不可篡改，POW节点是CAS网络中的“记账见证者”，而DPOS节点是CAS网络中的“记账工作者”。

与传统挖矿打包的对象为交易不同，CAS挖矿打包的对象为DPOS生成的区块，为了保证POW达成全网共识，并且POW打包验证区块的速度不至于远远落后DPOS生产的区块速度，POW打包验证是通过一次验证N（待定）个DPOS生成的区块，经过工作量证明生成新的区块，在高速系统中，多个DPOS区块包含大量的交易可能造成网络传输问题，所以CAS挖矿生成的区块中会存储DPOS生成区块的HASH。考虑到矿池集中的风险，对挖矿的叔区块和侄儿区块进行少量的奖励分配。

### 智能合约 

智能合约是一套以数字形式定义的承诺，包括合约参与方可以在上面执行这些承诺的协议。数字形式意味着合约必须写入计算机可读的代码中，只要参与方达成协定，智能合约建立的权利和义务，都将由一台计算机或者计算网络执行。

智能合约是编写在区块链上的程序，它不依赖某个特定的硬件设备，由所有参与挖矿的设备来执行。代码的执行应该是自动且原子的，要么成功执行，要么所有的状态变化都撤消。在区块链中，这非常重要，因为它避免了合约部分执行的情况。

智能合约目前还处于发展的初级阶段，区块链问世以来，关于智能合约的争论就层出不穷，已经有了多种实现，但是各种实现都有不同的问题，比如比特币的脚本只能支撑的数字货币转账的业务，非常单一，还有以太坊的智能合约曾经出现过多次高风险的漏洞，受资金损失高达数千万美金。

为了避免出现这些问题，CAS提出了自己的智能合约，CAS的智能合约设计既要保证简单、实用和易于理解，又要保证足够的灵活和可靠。它不同于比特币的脚本，可以支撑转账以外更加复杂的业务场景；它也不同于以太坊的智能合约，出现高危漏洞的可能性更小。

#### CAS智能合约与其它实现的对比 

#### 为什么不直接采用比特币的脚本 

作为区块链的首个成功案例，比特币经过了时间的检验，它的脚本非常的简单高效，而且出错很少。但是比特币的脚本的功能相对简单，只能支持签名、验签、加密和hash等功能，对业务的支持相对薄弱，只能完成简单的转账业务，无法支持更复杂的业务逻辑。

为了支撑更复杂的业务场景和业务逻辑，CAS必须通过一种方式来提升脚本的逻辑表达能力，具体的方式会在后续章节描述。

#### 为什么不选择图灵完备的虚拟机来执行合约 

THE DAO项目曾经在以太坊上通过ICO募集了大量资金，但是由于递归调用的合约漏洞问题，该项目遭受了无法弥补的巨额损失，损失高达1.5亿美金。这种损失对于金融系统的影响是非常负面的。

这种恶劣的漏洞的发生正是由于以太坊采用了图灵完备的虚拟机来实现智能合约。这种虚拟机的复杂性决定了它出现漏洞可能性相对较高，比如语法解析、复杂语法执行，甚至业务逻辑的编写也更容易出现漏洞。这样就给攻击者以可乘之机，攻击者可以通过各种手段来攻击以太坊平台以获取利益。

所以CAS平台在实现智能合约的选择上是非常谨慎的，既要避免复杂的虚拟机带来的高风险，又要避免过高的自由度以致业务方编写逻辑容易出错。

#### CAS的智能合约 

为了避免陷入上述比特币的脚本和以太坊的智能合约的问题，CAS将会实现一种简易稳定的脚本执行框架，语法类似于JavaScript，但是脚本中并不支持较为复杂的语法逻辑。在简化了语法，限制了高危功能的前提下，脚本的执行就会变得简单有效，不容易出错。

但是这样又带来了一个问题，CAS的智能合约可能无法满足一些较为复杂的业务场景。为了解决这个问题，CAS将会在智能合约之外扩充对业务的支撑，在基础平台上集成丰富的接口来实现脚本无法完成的一些通用的业务逻辑。业务方在智能合约中调用这些可靠的接口来配合脚本以便实现复杂的业务逻辑。比如划转CAS币这种高风险操作，我们会提供接口来实现，接口的输入会受到严格的检查，避免出现挪用，误扣的情况。接口的实现是通过成熟的语言（比如Java）进行编写，并且经过严密的测试。

### CAS的隐私性和隔离性设计 

在CAS上运行业务和代币平台，因此隐私性和隔离性是必须要实现的功能。

#### 业务的隔离性需求 

CAS可以提供代币平台服务，会有大量的代币业务运行在CAS网络中，业务数据必须要进行相应的隔离，从而确保所有业务只能访问相关数据，并且每个账户只能访问自己的数据。CAS通过VN、RS和Policy等模块的设计来满足此需求。

#### CAS的三层隔离机制的设计 

三层隔离机制的设计就是为了满足上述的不同隔离需求。

概要设计：

<img src="/img/cas12.png" >

#### VN隔离设计  

当Slave完成了区块的打包和入链，这些区块会逐层向上返回，此时，Synchronizer将根据不同的业务做区分（根据VNid），将block发到对应的VN，构建在CAS上的其它VN无法收到这个block，从而实现了在VN层面的隔离。

#### RS隔离性设计 

对于同一个业务也存在同样的需求，除交易双方外的第三方都不不应该能看到这个交易的详细信息，VN在将这些block向RS传输时，会运行定制在Policy中的智能合约，该合约将指定这个交易数据将会发给哪些RS（通过RSid），其它的处于同一个业务下的第三方是无法得到交易信息的，通过这种做法，满足了RS隔离的需求。

#### 账户隔离设计 

同一业务的交易双方最多只能识别对方的部分数据。RS收到VN返回的block信息时，RS只能识别出自己维护的账户的相关数据，交易方之间能部分识别对方数据，非交易方之间不能互相识别对方的数据，从而实现了账户层面的隔离。

### 账户隔离的方法 – Policy模型的设计 

#### VN、RS需求描述 

任何一笔交易都需要对应业务中至少一个RS参与。当某个业务的RS发起一笔交易请求时（此请求描述了一笔至少两方参与的交易），需要根据交易类型指定相应的Policy，此Policy会在VN上执行，从而让其他RS参与此交易。另外，当VN收到下层返回的block时，也需要运行Policy来决定向哪些RS返回相关数据。

#### Policy 模块的设计 

Policy的功能主要包含以下几方面： 

+ 为一个交易指定特定的投票方和投票方法。

+ 为一个打包完成的交易指定返回的RS节点。

+ 业务代币的使用规则的制定。

+ Policy通过智能合约来实现具体功能 

+ Policy的投票参与者可以通过智能合约来指定，比如根据RS的状态动态地确定实际的参与者。

+ Policy的投票逻辑可以通过智能合约实现，这样VN在请求RS投票时，会要求它执行合约的逻辑。

+ Policy的隐藏规则可以通过智能合约来实现，在基础的隔离性要求下，扩展实现个性化的隐藏需求。

+ Policy的业务代币使用规则可以通过智能合约来实现。

+ Policy的制定权问题 

根据前面对Policy的描述，可以发现不同的业务可能需要定制（或编写）不同的Policy，因此一个Policy的创建、指定和更改都应该由不同的业务自行维护，其它处于业务中的交易节点（体现为RS）只能按照业务要求对Policy进行导入，但无权限进行更改。另外，为了处理不同业务，也可以在Policy中加入业务方的特殊需求，比如在每次业务中使用每个业务自己的业务代币。

## 第四章共治社区 

### 共治社区的目标 

CAS是去中心化平台，没有中心化的管控，与传统平台由平台提供方进行平台维护和功能更新的方式不同，CAS平台的维护采用共治社区模式，需要所有参与节点共同对社区的健康发展负责。共治社区模式中，整个社区对发展提议进行投票，对通过的决议进行实施达到生态共治，大众共同参与决定社区的发展。只有在一个健康的社区环境下，平台的发展才会走上良性轨道，整个平台才能迸发出更好的活力。

共治社区主要由提议提交者、CAS联席委员会、提议投票者、决议实施者组成。CAS网络的投票决议制度请详见《CAS业务白皮书》，本文中主要讨论投票过程中的技术原理。

在提案投票流程中，CAS Coins的持有者可以进行投票，投票通过的提案称为社区决议，会由CAS开发团队通过发布新版本的CAS代码来实现。全网所有节点都是决议的实施者，接受决议并且实施，拒绝实施决议的节点，其请求将被网络拒绝。

通过决议共治流程来达到整个社区共治、平台健康发展的目标。

### CIP（CAS Improvement Proposals）投票

CAS社区将使得所有的符合一定条件的社区成员都拥有同等的权利来选择社区的发展方向，这正是共治社区的想要实现的目标，平台通过投票功能，保证这个目标的达成。

#### CAS社区的投票权 

社区将按照每个账户持有的CAS币的数量来分配投票权，按照一币一票的方式、同币同权，设计中严格保证禁止一币多票的情况产生，如账户A持有10个CAS币，则拥有10票，杜绝通过将CAS币转账到B账户，从而使得B账户也拥有10票这种行为，通过以下步骤实现：

+ 通过一个平台指定的智能合约完成投票权的发放，这个过程需要保证每个达到一定要求的账户都收到消息并运行合约，为用户账户产生针对某次特定决议的选票，选票将会与产生选票的凭据（比如 txID）一一映射，同时，该选票将被写入区块链。

+ 选票一旦被使用就将被置为无效，这点跟UTXO在原理上是一致的，选票的使用也采
用智能合约的方式。

#### 投票过程 

如果提议提交者希望对CAS生态进行优化，他们需要借助投票过程在整个社区内达成共识，才能让提议落地。只在小范围内达成共识的投票无法得到整个社区的认可，所以需要一定数量的参与者投票才能使得结果生效。但是社区也不能纵容恶意参与者无成本地加入，所以社区会为参与者设定门槛，这样可以提高投票的质量。

为了实现前面描述的规则，社区会对投票过程做出基础的约定，比如投票参与者数量的限制、赞成票数的限制、投票时间的下限和上限等。提议本身也会对投票做出约定，可能会有更加严格的投票人数的限制。这些约定都通过智能合约来承载执行。

有效的投票会在整个社区中广播，拥有投票资格的用户会在分布式浏览器上接收到投票内容。投票会简化为赞成和反对的形式，便于用户选择，一旦用户做出选择，则会反馈给社区并记录下来。

投票周期完成后，如果投票参与者数量和赞成票数都达到了平台和提议的要求，被赞成的提议会通过智能合约的检查，转化为最终的决议并记录在社区的待办决议中，决议会通过智能合约来具体实施。

### 共治社区奖励 

共治社会的任何有效决议都是通过大众自主投票按照一定规则选出的结果，此结果会对每个人产生影响。 

## 第五章CAS的可靠性、安全性、性能、部署和运维设计 

###  CAS的可靠性分析 
对于RS、VN、synchronizer以及CAS Slave 节点，可以由个人或者其它机构维护者维护，理论上，RS、VN最小都可以是一个节点，但显然这样做对高可用的服务是无法满足的，配置上RS、VN都需要是多个节点的。

Synchronizer 和 CAS Slave本身都是多节点的，对外都提供高可用服务，通过特别优化之后的一致性模块，CAS Slave可以承受不超过51%的节点掉线或数据丢失，节点掉线或者丢失在CAS平台上设计了failover的流程应对这样的场景，同时也支持因为上层业务系统的bug所引起的数据恢复服务。无论是RS、VN、CAS Slave的failover并不影响正常的业务运行。

### CAS性能分析和实际性能数据 

根据我们在测试系统（上千个CAS Slave节点）上测试的数据，RS、VN均部署在虚拟机节点上的性能，在TPS超过上万时，可以维持平均时延在秒级别。 

为了达到足够大的网络节点测试规模，采用在虚拟机上跑docker容器来创建足够多的节点，最大规模模拟了1000个网络节点的情况，通过在对不同规模的网络节点数进行压测获取tps和lantency数据如下：

|    Network Node Quantity    | tps | latency（s）|
| ---------- | --- | --- |
| 3 | 138363 | 0.23 |
| 5 | 136363 | 0.23 |
| 7 | 135363 | 0.25 |
| 13 | 125363 | 0.33 |
| 21 | 125063 | 0.37 |
| 49 | 	123054 | 	0.53 | 
| 99 | 	106307 | 	0.83 | 
| 149 | 	100432 | 	1.12 | 
| 199 | 	89643 | 	1.39 | 
| 249 | 	80157 | 	1.66 | 
| 299 | 	75189 | 	1.9 | 
| 349 | 	65954 | 	2.14 | 
| 399 | 	58669 | 	2.35 | 
| 449 | 	49549 | 	2.55 | 
| 499 | 	39810 | 	2.73 | 
| 549 | 	30666 | 	2.89 | 
| 599 | 	22335 | 	3.04 | 
| 649 | 	18031 | 	3.16 | 
| 699 | 	14013 | 	3.26 | 
| 749 | 	14001 | 	3.34 | 
| 799 | 	13631 | 	3.4 | 
| 849 | 	13331 | 	3.43 | 
| 899 | 	13337 | 	3.43 | 
| 949 | 	12971 | 	3.42 | 
| 999 | 	13092 | 	3.37 |

<img src="/img/cas17.png" >

<img src="/img/cas18.png" >

从数据和图的趋势可以看出当网络节点数量达到700左右时tps和latency趋于稳定状态，不再随着节点数的变化进行变化。

CAS共识算法在节点数变多时，需要更多的节点进行投票，同时由于网络开销增大从而导致latency增高。从压测数据中看出当网络规模大于700之后latency趋于平稳，这是由于在这个规模中，网络的广播的消耗趋于常数，节点之间形成的链接可以达到高效的信息广播；tps在大于这个规模也趋于稳定。

### 系统部署和系统运维 

系统部署：为了方便的进行部署，对于RS、VN和CAS Slave我们都有专门的一键部署脚本，部署脚本会跟随CAS所有源代码一起开源。

系统运维：CAS平台的基础监控和业务监控系统都是以开源的方式提供的，因为RS和VN本身开源决定业务系统的owner是可以根据自己的需要对监控系统进行修改的。同时，我们也提供故障处理工具，主要是针对发生故障后，处理failover和进行故障隔离等等。这些工具也都会进行开源。

### VN、RS、CAS Slave 的升级和扩容 

CAS作为一个分布式系统，无论是RS、VN、或者CAS Slave都需要考虑在线升级和扩容，目前，CAS平台针对升级和扩容的需要，已经完成相应的工具的开发、对升级和扩容也编写了相应的规范，通过运行工具，按照相应的规范与人工进行简单的交互就可以完成升级和扩容。





